# 图像基础处理算法

在浏览器添加  [MathJax Plugin for Github](https://chrome.google.com/webstore/detail/mathjax-plugin-for-github/ioemnmodlmafdkllaclgeombjnmnbima) 插件可以使得数学公式正常渲染。

## 源代码

- [Implementation of median filtering](medianblur.py)

## 基本概念

### 图像就是函数

我们能把一幅灰度图像看作是一个二维函数，定义成 f(x, y) 或者 I(x, y)。任何一对空间坐标  (x, y) 处 f 的值看作该坐标点处的强度 (intensity) 或灰度。对于彩色图像，同样可以看作是一个向量函数 `f(x, y) = [r(x, y), g(x, y), b(x, y)]`。

### 灰度图

灰度可以认为是亮度，简单说就是色彩的深浅程度。

灰度就是没有色彩，RGB 色彩分量全部相等（可以使用画图工具来做测试，如果 RGB 三个通道的值都相等，那么最终的颜色就是从纯黑到白之间不同等级的灰色）。如果一个二值灰度图像，它的像素值只能为 0 或 1，我们说它的灰度级为2.用个例子来说吧：一个256级灰度图你，　　　

- RGB（100，100，100）就代表灰度为100，RGB（50，50，50）就代表灰度为50。

灰度是指黑白图像中的颜色深度，范围一般0-255，白色为255，黑色为0，故黑白图片也称为灰度图像。
　　若是彩色图像的灰度其实是在转化为黑白图像后的像素值（是一种广义的提法），转化的方法看应用领域而定，一般按加权的方法转换，R,G,B的一般比例为3： 6：1。
任何颜色都有红、绿、蓝三原色组成，假如原来某点的颜色为RGB（R,G,B），那么，我们可以通过下面几种方法，将其转换为灰度：
```
　　1.浮点算法：Gray = R*0.3 + G*0.59 + B*0.11
　　2.整数方法：Gray = (R*30+G*59+B*11)/100
　　3.移位方法：Gray =（R*28+G*151+B*77）>> 8
　　4.平均值法：Gray = (R+G+B)/3
　　5.仅取绿色：Gray = G
```

通过以上任何一种方法求得 Gray 后，将原来的 RGB（r,g,b) 中的 r,g,b 统一用 Gray 替换，形成新的颜色 RGB(Gray,Gray,Gray)，用它替换原来的 RGB（r,g,b)  就是灰度图了。

### 灰度直方图

灰度直方图是关于灰度级分布的函数，是对图像中灰度级分布的统计。灰度直方图是将数字图像中的所有像素，按照灰度值的大小，统计其出现的频率。灰度直方图是灰度级的函数，它表示图像中具有某种灰度级的像素的个数，反映了图像中某种灰度出现的频率。

如果将图像总像素亮度（灰度级别）看成是一个随机变量，则其分布情况就反映了图像的统计特性，这可用 probability density function （PDF）来刻画和描述，表现为灰度直方图。

### 图像梯度

当用均值滤波器降低图像噪声的时候，会带来图像模糊的副作用。我们当然希望看到的是清晰图像。那么，清晰图像和模糊图像之间的差别在哪里呢？从逻辑上考虑，图像模糊是因为图像中物体的轮廓不明显，轮廓边缘灰度变化不强烈，层次感不强造成的，那么反过来考虑，轮廓边缘灰度变化明显些，层次感强些是不是图像就更清晰些呢。

那么，这种灰度变化明显不明显怎样去定义呢。我们学过微积分，知道微分就是求函数的变化率，即导数（梯度），那么对于图像来说，也可以用微分来表示图像灰度的变化率。

## 卷积


## 图像滤波

图像滤波既可以在实域进行，也可以在频域进行。图像滤波可以更改或者增强图像。通过滤波，可以强调一些特征或者去除图像中一些不需要的部分。滤波是一个邻域操作算子，利用给定像素周围的像素的值确定次像素的最终输出值。

$$
O(i,j)=∑_{m,n}I(i+m,j+n)∗K(m,n)
$$

其中 K 为滤波器，在很多文献中也成为核（kernel）。常见的应用包括去噪、图像增强、检测边缘、检测角点、模板匹配等。

###  图像锐化与边缘检测应用

图像锐化，求边缘等是常见的图像滤波应用。这类滤波器常常使用一节或者二阶差分（或微分，对于数字图像而言，其为离散信号，长用差分代替导数）核算子对图像进行滤波。一节差分常用于求取图像边缘。二阶差分常用于图像增强。常用的这类算子包括：

#### Sobel

Sobel operator：Sobel 算子通过计算水平和垂直方向上的一节差分来进行计算。在 OpenCV 函数中，可通过使用 [Sobel](http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=sobel#sobel) 函数进行计算。

#### Laplacian

 Laplacian operator：Laplacian 算子通过计算二阶差分（微分）来进行计算。在 OpenCV 函数中，可通过使用 [Laplacian](http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=laplacian#laplacian) 函数进行计算。

### 图像平滑应用

用于平滑图像的常见滤波算子包括：

#### 均值滤波

用其像素点周围像素的平均值代替原像素值，在滤除噪声的同时也会滤掉图像的边缘信息。在 OpenCV 中，可以使用 `boxFilter` 和 blur 函数进行均值滤波，均值滤波的核为：

![\frac{1}{ksize.width{\cdot}ksize.height}\begin{bmatrix} {1}&{1}&{\cdots}&{1}\\ {1}&{1}&{\cdots}&{1}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {1}&{1}&{\cdots}&{1}\\ \end{bmatrix}](http://latex.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7Bksize.width%7B%5Ccdot%7Dksize.height%7D%5Cbegin%7Bbmatrix%7D%20%7B1%7D%26%7B1%7D%26%7B%5Ccdots%7D%26%7B1%7D%5C%5C%20%7B1%7D%26%7B1%7D%26%7B%5Ccdots%7D%26%7B1%7D%5C%5C%20%7B%5Cvdots%7D%26%7B%5Cvdots%7D%26%7B%5Cddots%7D%26%7B%5Cvdots%7D%5C%5C%20%7B1%7D%26%7B1%7D%26%7B%5Ccdots%7D%26%7B1%7D%5C%5C%20%5Cend%7Bbmatrix%7D)

#### 中值滤波（MedianFilter）

中值滤波用测试像素周围邻域像素集中的中值代替原像素。中值滤波去除椒盐噪声和斑块噪声时，效果非常明显。在 OpenCV 中可以用函数 `medianBlur` 进行操作。

无论是平均平滑还是高斯平滑，在处理图像噪声时，都或多或少会对图片产生一定的模糊，损失部分信息。较为理想的情况，是可以选择性地进行滤波，只在噪声区域进行平滑，而在无噪声区域不进行平滑，将模糊的影响降到最低，这就是自适应性滤波的思想。通常噪声的存在，可能会使得附近邻域内，极值的上下差距较大，或者是方差较大，我们可以设置一定的阈值来判断该点是否需要进行平滑。不过这个不是该章节的内容，这一章是要学习中值滤波，中值滤波本质上是一个**统计排序滤波器**，是以该点为中心的的邻域内的所有像素的统计排序中值作为该点的响应；而平滑就是加权平均数作为响应，概念上有一定差别。

不同的滤波器在处理不同类型的噪声是效果不同，对于线性平滑滤波，在处理像素邻域内的噪声点时，噪声或多或少都会影响该点的像素值计算(以高斯平滑为例，距离近则影响大，距离远则影响小，与距离的平方呈反比)；但是中值滤波通常可以将噪声点直接忽略掉。同时，中值滤波在降噪的同时引起的模糊效应较低。中值滤波的一种典型应用，就是用来消除椒盐(salt & pepper)噪声。

#### 高斯滤波

高斯滤波为最常用的滤波器，具有可分离性质，可以把二维高斯运算转换为一维高斯运算，其本质上为一个低通滤波器。在OpenCV中可通过函数 [GaussianBlur](http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=gaussianblur#gaussianblur) 进行操作。

模糊的算法有很多种，其中一种叫做高斯模糊（Gaussian Blur）。它将正态分布（又名高斯分布）用于图像处理。高斯模糊本质是一种数据平滑技术（data smoothing），适用于多个场合，图像处理提供了一个直观的应用实例可参考 [《高斯模糊（高斯滤波）的原理与算法》](https://blog.csdn.net/nima1994/article/details/79776802)。

- 均值滤波是简单的取平均值，模板系数都是 1。而图像上的像素实际上是坐标离散但是值却连续的，因为与靠近点的关系越密切，越远离的点关系越疏远。因此，加权平均更合理，举例越近的点权重越大，距离越远的点权重越小

- 既然是依据距离来加权平均，那么很容易想到高斯函数 $f(x) = \frac{1}{\sigma\sqrt{2\pi }}{e}^{\frac{-(x-\mu )^{2}}{2\sigma^2}}$，从高斯函数来看，离原点距离越近，得到的权重越高，越远离原点，得到的权重越小

- 一维的高斯函数，当中心点为原点时，x 的均值 μ = 0， 此时 $f(x) = \frac{1}{\sigma\sqrt{2\pi }}{e}^{\frac{-x^{2}}{2\sigma^2}}$
- 由于图像是二维矩阵，则采用二维高斯函数 $f(x,y) = \frac{1}{{2\pi }\sigma^2}{e}^{\frac{-(x^2+y^2 )}{2\sigma^2}}$，有了这个函数就可以计算滤波模板中各个点的权重了

##### 生成高斯核

通过 cv2 中的 `getGaussianKernel` 函数可以根据指定参数规模和方差生成高斯卷积核：

```
k = cv2.getGaussianKernel(3,1.5)
```

通过该函数生成的一维卷积核 k 已经进行过归一化处理。

归一化化定义：归一化就是要把需要处理的数据经过处理后（通过某种算法）限制在你需要的一定范围内。
首先归一化是为了后面数据处理的方便，其次是保证程序运行时收敛加快。归一化的具体作用是归纳统一样本的统计分布性。
归一化在0-1之间是统计的概率分布，归一化在某个区间上是统计的坐标分布。归一化有同一、统一和合一的意思。

- 规模为`3*3`，方差为 1.5 的一维卷积核  k 为：

```
[[0.30780133]
 [0.38439734]
 [0.30780133]]
```

- 通过 k*(k.T) 运算可以获得二维卷积核

```
[[0.09474166 0.11831801 0.09474166]
 [0.11831801 0.14776132 0.11831801]
 [0.09474166 0.11831801 0.09474166]]
```

##### 高斯滤波加速

对图像进行高斯滤波而言，假设滤波器半径为 r，我们常用的高斯模板则对于图像每个像素的算法复杂度是 O(r^2)。高斯滤波器的 kernel 是可分离的(separable)，也就是说，可以将 2D 的高斯 kernel 分解为两个 1D 的 kernel，先沿 x 方向对图像进行 1D 高斯 kernel 的卷积，然后沿 y 方向对图像进行 1D 的高斯 kernel 卷积，最后的结果和使用一个 2D 高斯 kernel 对图像卷积效果是一样的。这样一来，针对每个像素，滤波器的算法复杂度降为 O(r)。

### 双边滤波

双边滤波在平滑图像时能够很好的保留边缘特性，但是其运算速度比较慢。在 OpenCV 中，可以使用函数 [bilateralFilter](http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=bilateralfilter#bilateralfilter) 进行操作。

### 自定义滤波器

除了上面列举的较为经典的滤波器（或者说是核算子）外，在 OpenCV 中也可以自己定义自己的滤波器，然后使用 [filter2D](http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=filter2d#filter2d) 函数进行运算。

## 特征描述算法

### What is a good feature point?
#### Harris Corner
- Very informational (Harris Corner Detector)
- Rotation/Brightness resistance (Harris Corner Detector)
- Scale resistance (Harris Corner Detector)

### What is the form of a feature point?
- Physical in location
- Abstract in formation (usually a vector) -> Feature Descriptor

### How to get a feature point/descriptor?
#### SIFT

[SIFT](https://www.cnblogs.com/hepc/p/9636474.html)，即尺度不变特征变换（Scale-invariant feature transform，SIFT），是用于 [图像处理](https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/294902) 领域的一种描述。这种描述具有尺度不变性，可在图像中检测出关键点，是一种局部特征描述子。

SIFT 特征是基于物体上的一些局部外观的兴趣点而与影像的大小和旋转无关。对于光线、噪声、微视角改变的容忍度也相当高。基于这些特性，它们是高度显著而且相对容易撷取，在母数庞大的特征数据库中，很容易辨识物体而且鲜有误认。使用 SIFT 特征描述对于部分物体遮蔽的侦测率也相当高，甚至只需要 3 个以上的 SIFT 物体特征就足以计算出位置与方位。在现今的电脑硬件速度下和小型的特征数据库条件下，辨识速度可接近即时运算。SIFT 特征的信息量大，适合在海量数据库中快速准确匹配。

1. Generate Scale-space: DoG (Difference of Gaussian)

   - 采用高斯函数对图像进行模糊以及降采样处理得到高斯金字塔
   - 采用 DOG 在高斯金子塔中的每组中相邻两层相减（“下一层减上一层”）生成高斯差分金字塔

2. Scale-space Extrema Detection

   找到局部极值点

3. Accurate Keypoint Localization

   通过 Taylor 展开式（插值函数）精确定位关键点

4. Eliminating Edge Responses

   通过 [Hessian 矩阵](http://www.docin.com/p-940982857.html) 消除边缘响应点

5. Orientation Assignment

   对关键点进行梯度计算生成梯度直方图，统计领域内像素的梯度和方向，从而确定主（辅）方向，计算梯度大小和方向时使用了 `prewitt` 算子

   $$
   𝑟 =3*1.5𝜎
   $$

   $$
   𝑚(𝑥, 𝑦) = \sqrt{(𝐿(𝑥 + 1, 𝑦) − 𝐿(𝑥 − 1, 𝑦))^2 + (𝐿(𝑥, 𝑦 + 1) − 𝐿(𝑥, 𝑦 − 1))^
   2} = \sqrt{G_x^2-G_y^2}
   $$

   $$
   𝜃(𝑥, 𝑦) = arctan(\frac{𝐿(𝑥, 𝑦 + 1) − 𝐿(𝑥, 𝑦 − 1)}{𝐿(𝑥 + 1, 𝑦) − 𝐿(𝑥 − 1, 𝑦)}) =  arctan(\frac{G_y}{G_x})
   $$

6. Keypoint Descriptor

   取特征点周围 `4*4` 个区域块，统计每小块内 8 个梯度方向的幅值，用这 `4*4*8=128` 维向量作为 SOFT 特征的描述子

有了关键点描述子之后，就可以用相关算法对不同图片中的关键点描述子进行匹配。

#### HoG

梯度方向直方图  (Histogram of Oriented Gradient, HOG) 是图像处理经典的特征提取算法。HOG 特征是直接将图像像素点的方向梯度作为图像特征，包括梯度大小和方向。通过计算图像局部区域的梯度直方图特征，然后将局部的特征串联起来，构成整幅图像的 HOG 特征。

- 主要思想

    在一幅图像中，局部目标的表象和形状（appearance and shape）能够被梯度或边缘的方向密度分布很好地描述。（本质：梯度的统计信息，而梯度主要存在于边缘的地方）。

- 实现方法

    首先将图像分成小的连通区域，我们把它叫细胞单元。然后采集细胞单元中各像素点的梯度的或边缘的方向直方图。最后把这些直方图组合起来就可以构成特征描述器。

- 提高性能

    把这些局部直方图在图像的更大的范围内（我们把它叫区间或 block）进行对比度归一化（contrast-normalized），所采用的方法是：先计算各直方图在这个区间（block）中的密度，然后根据这个密度对区间中的各个细胞单元做归一化。通过这个归一化后，能对光照变化和阴影获得更好的效果。

- 优点

    与其他的特征描述方法相比，HOG 有很多优点。首先，由于 HOG 是在图像的局部方格单元上操作，所以它对图像几何的和光学的形变都能保持很好的不变性，这两种形变只会出现在更大的空间领域上。其次，在粗的空域抽样、精细的方向抽样以及较强的局部光学归一化等条件下，只要行人大体上能够保持直立的姿势，可以容许行人有一些细微的肢体动作，这些细微的动作可以被忽略而不影响检测效果。因此 HOG 特征是特别适合于做图像中的人体检测的。

#### RANSAC

随机抽样一致算法（RANdom SAmple Consensus, RANSAC）,采用迭代的方式从一组包含离群的被观测数据中估算出数学模型的参数。RANSAC 算法假设数据中包含正确数据和异常数据（或称为噪声）。正确数据记为内点（inliers），异常数据记为外点（outliers）。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。该算法核心思想就是随机性和假设性，随机性是根据正确数据出现概率去随机选取抽样数据，根据大数定律，随机性模拟可以近似得到正确结果。假设性是假设选取出的抽样数据都是正确数据，然后用这些正确数据通过问题满足的模型，去计算其他点，然后对这次结果进行一个评分。

RANSAC 算法被广泛应用在计算机视觉领域和数学领域，例如直线拟合、平面拟合、计算图像或点云间的变换矩阵、计算基础矩阵等方面，使用的非常多。

例如拟合一个直线模型，使用 RANSAC 算法可以遵循如下步骤：

1. 需要两个点唯一确定一个直线方程，所以第一步随机选择两个点
2. 通过这两个点，可以计算出这两个点所表示的模型方程 y=ax+b，计算其系数和截距
3. 将所有的数据点套到这个模型中计算误差
4. 找到所有满足误差阈值的点的个数
5. 重复前 4 步迭代过程，直到达到一定迭代次数后，选出那个满足指定误差点数最多的模型，作为问题的解

#### 总结

我觉得通过 SIFT 算法的 5、6 步来获取特征描述子的过程和 HOG 获取局部特征的方法非常类似。都是先统计一个小单元上的梯度直方图，然后再组合其周边一小片局域的直方图左右着一片区域的特征描述。本质上是他们认为局部像素的梯度和方向可以表示这一片区域的特征。
